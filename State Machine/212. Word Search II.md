# **. **

[LeetCode ]()

## Problem



## Methods
Intuition: 


### Code
```JavaScript
/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */

// state machine
function Node(ch) {
    this.ch = ch;
    this.children = {};
    this.visited = false;
}

var findWords = function(board, words) {
    // entry point
    let root = new Node("");
    
    let dict = {};
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[0].length; j++) {
            let newCh = board[i][j];
            let newNode = new Node(board[i][j]);
            if (newCh in root.children) {
                root.children[newCh].push(newNode);
            } else {
                root.children[newCh] = [newNode];
            }
            dict[i * board.length + j] = newNode;
        }
    }
    
    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[0].length; j++) {
            let currNode = dict[i * board.length + j];
            for (let [di, dj] of dirs) {
                let newi = i + di, newj = j + dj;
                // boundary check 
                if (newi < 0 || newj < 0 || newi >= board.length || newj >= board[0].length) {
                    continue;
                }
                
                let newCh = board[newi][newj];
                let newNode = dict[newi * board.length + newj];
                if (newCh in currNode.children) {
                    currNode.children[newCh].push(newNode);
                } else {
                    currNode.children[newCh] = [newNode];
                }
            }
        }
    }
    
    const dfs = (suffix, node) => {
        // base case
        console.log(suffix, node)
        if (suffix.length === 0) return true;
        if (!(suffix[0] in node.children)) return false;
        
        let hasWord = false;
        for (let nextNode of node.children[suffix[0]]) {
            if (nextNode.visited) continue;
            nextNode.visited = true;
            hasWord = hasWord || dfs(suffix.slice(1), nextNode);
            nextNode.visited = false;
        }
        
        return hasWord;
    }
    
    // iterate through all words
    return words.filter(word => dfs(word, root));
};
```

### Reference

